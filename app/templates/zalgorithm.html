<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title id='Z Algorithm'>The Z Algorithm</title>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
  <style>
    h1 {
      text-align: center;
    }
    p {
      text-align: justify;
    }
    img {
      max-width: 100%;
    }
    .segment {
      display: none;
    }
    #para1 {
      display: block;
    }
    .btn-group {
      padding-top: 25px;
    }
  </style>
  <script src="//code.jquery.com/jquery-1.10.2.js"></script>
  <script>
    function showElement(id, oldid) {
      document.getElementById(id).style.display = 'block';
      document.getElementById(oldid).style.display = 'none';
    }
</script>
</head>

<body>
<h1>The Z Algorithm</h1>

<br> 
<div class="container">

<div class="segment" id="para1">
<p>This page aims to explain the processes involved in the Z Algorithm. The Z Algorithm is an algorithm used for exact string matching. It is far more efficient than the brute force algorithm, as its time complexity is only O(m+n), rather than O(n^2). On large datasets, this is an enormous improvement.</p>

<p>The first step when finding the substring in the string is to concatenate the two strings. Because of the way the Z Algorithm works, it is important to place the substring before the main string. This way the substring itself is the "prefix" that the algorithm compares the other characters against, and thus it is the substring (which we are looking for) that will be found when searching the string.</p>

<p>One final thing is necessary between the substring and string. This is a character, a single character, which is not present in either the string or the substring. This creates a clear barrier between the two, and ensures that the "prefix" is limited to the substring only.</p>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para2', 'para1');">Continue on</button>
</div>
</div>
</div>

<div  class="segment" id="para2">
<p>Now we have our string set up, lets look at the Z Algorithm itself:</p>

We have three variables of note:
<ul>
  <li>l (our pointer to the left of the substring we're looking at)</li>
  <li>r (our right pointer)</li>
  <li>k (index of the character being looked at)</li>
</ul>

<p>For each value of k, we're trying to find the value of Zk, where Zk is the length of the longest substring that starts at k and matches the prefix of the string (remembering that, with how the string is set up, out substring is the prefix!).</p>

<p>Given that our prefix is the substring, followed by an "unmatchable" character, how long do you think the longest substrings we find will be?</p>

<br>
<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para3', 'para2');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para3">
<p>Answer: the length of the substring.</p>
<p>And why is this? This is because we start at the beginning of the string that we've made by concatenating our substring, an unmatchable character, and the string to be searched (e.g. GATT$CCGAGATTCG). No matter where we are in the string, $ is unmatchable, so there cannot be a Zk greater than the length of our substring and any substring of this length MUST be a repetition of the substring itself!.</p>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para4', 'para3');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para4">
<p>Now for a deeper look at the algorithm. Within the algorithm, there are three options for how the index is analysed. These are:</p>
<ol>
  <li>k &gt; r. If this is the case, find Zk by explicitly comparing characters starting at index k with those starting at index 0 until a mismatch is found. The length of the match is Zk. If Zk &gt; 0, set r to k + Zk and set l to k.</li>
  <li>k &lt;= r. In this case, k is contained in a previous longest substring (also known as a Z box), so the character at index k also appears at k’ (where k’ = k-l) in the string.  Thus it follows that the substring [k... r] is replicated earlier in the string at [k’...k’+Kk’]. Because we know it is replicated (because we’ve already matched it previously), we know that the length of the match at this point is at minimum the length of that already calculated at k’. This length can be expressed as b (where b=r-k). There are two subcases based on this:
    <ol>
      <li>Zk’ &lt; b. If this is the case, Zk = Zk’. Thus, r and l remain unchanged as the longest substring still covers the area being examined.</li>
      <li>Zk’ &gt;= b. In this case, the entire substring [k...r] must be a prefix. However, Zk may be larger than b so compare the characters starting at index r to those starting at b until a mismatch occurs. Lets say this mismatch occurs at q (where q &gt;= r+1). In this case, Zk = q-k, r=q and l=k because we’ve found a new longest substring.
    </ol>
  </li>
</ol>

<p>This is repeated for every index in the string until the end is reached. Once here, iterating through the saved Zk values will yield the index of each repetition of the substring in the main string.</p>

<br>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para5', 'para4');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para5">
The next step is to look at an example, which will hopefully help to amake things a bit clearer. In this case we will use the following strings:
<ul>
  <li>String (S): GAGAAGGCTTCACGCTTCACGCTTA</li>
  <li>Substring (T): GCTTCACGC</li>
</ul>

<p>When we put them together to form the string to search from, we get:
GCTTCACGC$GAGAAGGCTTCACGCTTCACGCTTA. Note that $ has been used for the demarkation symbol, but anything that is not in either strings' alphabet can be used.</p>

<p>Now, on to the analysis.</p>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para6', 'para5');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para6">
<img src='../static/img/Z1.jpg' id='Z1'>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para7', 'para6');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para7">
<img src='../static/img/Z2.jpg' id='Z2'>

<div class="btn-group btn-group-justified">

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para8', 'para7');">Continue on</button>
</div>
</div>
</div>
</div>

<div class="segment" id="para8">
<img src='../static/img/Z3.jpg' id='Z3'>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para9', 'para8');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para9">
<img src='../static/img/Z4.jpg' id='Z4'>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para10', 'para9');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para10">
<img src='../static/img/Z5.jpg' id='Z5'>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para11', 'para10');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para11">
<p>The rest of the string matching has been left as an exercise to the reader, but a running set of all variable values for each step is below, to help guide things along. There are two repetitions of the substring in the main string.</p>

<p>If you want to write some code to further understand how this algorithm works, then I recommend having a go at <a href="rosalind.info/problems/subs/">this problem on Rosalind</a>, a Bioinformatics problem solving portal. You need to do a couple of little problems beforehand to get to that problem, but that only adds to the fun!</p>

<div class="btn-group btn-group-justified">
<div class="btn-group">
  <button type="button" class="btn btn-default" onClick="showElement('para12', 'para11');">Continue on</button>
</div>
</div>
</div>

<div class="segment" id="para12">
<p>Key: (case used , l after step completed, r after step completed). The number of the dotpoint indicates the index of the character being examined.</p>
<ol>
<li>(1, 0, 0)</li>
<li>(1, 0, 0)</li>
<li>(1, 0, 0)</li>
<li>(1, 0, 0)</li>
<li>(1, 0, 0)</li>
<li>(1, 0, 0)</li>
<li>(1, 0, 0)</li>
<li>(2, 7, 9)</li>
<li>(3, 7, 9)</li>
<li>(1, 9, 9)</li>
<li>(3, 10, 11)</li>
<li>(1, 11, 11)</li>
<li>(3, 12, 13)</li>
<li>(1, 13, 13)</li>
<li>(1, 13, 13)</li>
<li>(3, 15, 16)</li>
<li>(2, 16, 25)</li>
<li>(2, 16, 25)</li>
<li>(2, 16, 25)</li>
<li>(2, 16, 25)</li>
<li>(2, 16, 25)</li>
<li>(2, 16, 25)</li>
<li>(3, 16, 25)</li>
<li>(2, 23, 32)</li>
<li>(2, 23, 32)</li>
<li>(2, 23, 32)</li>
<li>(2, 23, 32)</li>
<li>(2, 23, 32)</li>
<li>(2, 23, 32)</li>
<li>(3, 23, 32)</li>
<li>(2, 30, 34)</li>
<li>(2, 30, 34)</li>
<li>(2, 30, 34)</li>
<li>(3, 30, 34)</li>
</ol>
</div>
</div>
</body>
</html>
